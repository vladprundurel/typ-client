import { __decorate, __spread, __assign } from 'tslib';
import { ɵɵdefineInjectable, Injectable, EventEmitter, ElementRef, Input, Output, Directive, NgModule } from '@angular/core';
import { Chart as Chart$1 } from 'chart.js';
import { BehaviorSubject } from 'rxjs';
import { cloneDeep } from 'lodash-es';

var defaultColors = [
    [255, 99, 132],
    [54, 162, 235],
    [255, 206, 86],
    [231, 233, 237],
    [75, 192, 192],
    [151, 187, 205],
    [220, 220, 220],
    [247, 70, 74],
    [70, 191, 189],
    [253, 180, 92],
    [148, 159, 177],
    [77, 83, 96]
];

/**
 * Generate colors by chart type
 */
function getColors(chartType, index, count) {
    if (chartType === 'pie' || chartType === 'doughnut') {
        return formatPieColors(generateColors(count));
    }
    if (chartType === 'polarArea') {
        return formatPolarAreaColors(generateColors(count));
    }
    if (chartType === 'line' || chartType === 'radar') {
        return formatLineColor(generateColor(index));
    }
    if (chartType === 'bar' || chartType === 'horizontalBar') {
        return formatBarColor(generateColor(index));
    }
    if (chartType === 'bubble') {
        return formatPieColors(generateColors(count));
    }
    if (chartType === 'scatter') {
        return formatPieColors(generateColors(count));
    }
    throw new Error("getColors - Unsupported chart type " + chartType);
}
function rgba(colour, alpha) {
    return 'rgba(' + colour.concat(alpha).join(',') + ')';
}
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function formatLineColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.4),
        borderColor: rgba(colors, 1),
        pointBackgroundColor: rgba(colors, 1),
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: rgba(colors, 0.8)
    };
}
function formatBarColor(colors) {
    return {
        backgroundColor: rgba(colors, 0.6),
        borderColor: rgba(colors, 1),
        hoverBackgroundColor: rgba(colors, 0.8),
        hoverBorderColor: rgba(colors, 1)
    };
}
function formatPieColors(colors) {
    return {
        backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),
        borderColor: colors.map(function () { return '#fff'; }),
        pointBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
        pointBorderColor: colors.map(function () { return '#fff'; }),
        pointHoverBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
        pointHoverBorderColor: colors.map(function (color) { return rgba(color, 1); })
    };
}
function formatPolarAreaColors(colors) {
    return {
        backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),
        borderColor: colors.map(function (color) { return rgba(color, 1); }),
        hoverBackgroundColor: colors.map(function (color) { return rgba(color, 0.8); }),
        hoverBorderColor: colors.map(function (color) { return rgba(color, 1); })
    };
}
function getRandomColor() {
    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
}
/**
 * Generate colors for line|bar charts
 */
function generateColor(index) {
    return defaultColors[index] || getRandomColor();
}
/**
 * Generate colors for pie|doughnut charts
 */
function generateColors(count) {
    var colorsArr = new Array(count);
    for (var i = 0; i < count; i++) {
        colorsArr[i] = defaultColors[i] || getRandomColor();
    }
    return colorsArr;
}

var ThemeService = /** @class */ (function () {
    function ThemeService() {
        this.pColorschemesOptions = {};
        this.colorschemesOptions = new BehaviorSubject({});
    }
    ThemeService.prototype.setColorschemesOptions = function (options) {
        this.pColorschemesOptions = options;
        this.colorschemesOptions.next(options);
    };
    ThemeService.prototype.getColorschemesOptions = function () {
        return this.pColorschemesOptions;
    };
    ThemeService.ɵprov = ɵɵdefineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });
    ThemeService = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], ThemeService);
    return ThemeService;
}());

var UpdateType;
(function (UpdateType) {
    UpdateType[UpdateType["Default"] = 0] = "Default";
    UpdateType[UpdateType["Update"] = 1] = "Update";
    UpdateType[UpdateType["Refresh"] = 2] = "Refresh";
})(UpdateType || (UpdateType = {}));
var BaseChartDirective = /** @class */ (function () {
    function BaseChartDirective(element, themeService) {
        this.element = element;
        this.themeService = themeService;
        this.options = {};
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.old = {
            dataExists: false,
            dataLength: 0,
            datasetsExists: false,
            datasetsLength: 0,
            datasetsDataObjects: [],
            datasetsDataLengths: [],
            colorsExists: false,
            colors: [],
            labelsExist: false,
            labels: [],
            legendExists: false,
            legend: {},
        };
        this.subs = [];
    }
    /**
     * Register a plugin.
     */
    BaseChartDirective.registerPlugin = function (plugin) {
        Chart$1.plugins.register(plugin);
    };
    BaseChartDirective.unregisterPlugin = function (plugin) {
        Chart$1.plugins.unregister(plugin);
    };
    BaseChartDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.ctx = this.element.nativeElement.getContext('2d');
        this.refresh();
        this.subs.push(this.themeService.colorschemesOptions.subscribe(function () { return _this.themeChanged(); }));
    };
    BaseChartDirective.prototype.themeChanged = function () {
        this.refresh();
    };
    BaseChartDirective.prototype.ngDoCheck = function () {
        var _this = this;
        if (!this.chart) {
            return;
        }
        var updateRequired = UpdateType.Default;
        var wantUpdate = function (x) {
            updateRequired = x > updateRequired ? x : updateRequired;
        };
        if (!!this.data !== this.old.dataExists) {
            this.propagateDataToDatasets(this.data);
            this.old.dataExists = !!this.data;
            wantUpdate(UpdateType.Update);
        }
        if (this.data && this.data.length !== this.old.dataLength) {
            this.old.dataLength = this.data && this.data.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (!!this.datasets !== this.old.datasetsExists) {
            this.old.datasetsExists = !!this.datasets;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.length !== this.old.datasetsLength) {
            this.old.datasetsLength = this.datasets && this.datasets.length || 0;
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter(function (x, i) { return x.data !== _this.old.datasetsDataObjects[i]; }).length) {
            this.old.datasetsDataObjects = this.datasets.map(function (x) { return x.data; });
            wantUpdate(UpdateType.Update);
        }
        if (this.datasets && this.datasets.filter(function (x, i) { return x.data.length !== _this.old.datasetsDataLengths[i]; }).length) {
            this.old.datasetsDataLengths = this.datasets.map(function (x) { return x.data.length; });
            wantUpdate(UpdateType.Update);
        }
        if (!!this.colors !== this.old.colorsExists) {
            this.old.colorsExists = !!this.colors;
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        // This smells of inefficiency, might need to revisit this
        if (this.colors && this.colors.filter(function (x, i) { return !_this.colorsEqual(x, _this.old.colors[i]); }).length) {
            this.old.colors = this.colors.map(function (x) { return _this.copyColor(x); });
            this.updateColors();
            wantUpdate(UpdateType.Update);
        }
        if (!!this.labels !== this.old.labelsExist) {
            this.old.labelsExist = !!this.labels;
            wantUpdate(UpdateType.Update);
        }
        if (this.labels && this.labels.filter(function (x, i) { return !_this.labelsEqual(x, _this.old.labels[i]); }).length) {
            this.old.labels = this.labels.map(function (x) { return _this.copyLabel(x); });
            wantUpdate(UpdateType.Update);
        }
        if (!!this.options.legend !== this.old.legendExists) {
            this.old.legendExists = !!this.options.legend;
            wantUpdate(UpdateType.Refresh);
        }
        if (this.options.legend && this.options.legend.position !== this.old.legend.position) {
            this.old.legend.position = this.options.legend.position;
            wantUpdate(UpdateType.Refresh);
        }
        switch (updateRequired) {
            case UpdateType.Default:
                break;
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
                this.refresh();
                break;
        }
    };
    BaseChartDirective.prototype.copyLabel = function (a) {
        if (Array.isArray(a)) {
            return __spread(a);
        }
        return a;
    };
    BaseChartDirective.prototype.labelsEqual = function (a, b) {
        return true
            && Array.isArray(a) === Array.isArray(b)
            && (Array.isArray(a) || a === b)
            && (!Array.isArray(a) || a.length === b.length)
            && (!Array.isArray(a) || a.filter(function (x, i) { return x !== b[i]; }).length === 0);
    };
    BaseChartDirective.prototype.copyColor = function (a) {
        var rc = {
            backgroundColor: a.backgroundColor,
            borderWidth: a.borderWidth,
            borderColor: a.borderColor,
            borderCapStyle: a.borderCapStyle,
            borderDash: a.borderDash,
            borderDashOffset: a.borderDashOffset,
            borderJoinStyle: a.borderJoinStyle,
            pointBorderColor: a.pointBorderColor,
            pointBackgroundColor: a.pointBackgroundColor,
            pointBorderWidth: a.pointBorderWidth,
            pointRadius: a.pointRadius,
            pointHoverRadius: a.pointHoverRadius,
            pointHitRadius: a.pointHitRadius,
            pointHoverBackgroundColor: a.pointHoverBackgroundColor,
            pointHoverBorderColor: a.pointHoverBorderColor,
            pointHoverBorderWidth: a.pointHoverBorderWidth,
            pointStyle: a.pointStyle,
            hoverBackgroundColor: a.hoverBackgroundColor,
            hoverBorderColor: a.hoverBorderColor,
            hoverBorderWidth: a.hoverBorderWidth,
        };
        return rc;
    };
    BaseChartDirective.prototype.colorsEqual = function (a, b) {
        if (!a !== !b) {
            return false;
        }
        return !a || true
            && (a.backgroundColor === b.backgroundColor)
            && (a.borderWidth === b.borderWidth)
            && (a.borderColor === b.borderColor)
            && (a.borderCapStyle === b.borderCapStyle)
            && (a.borderDash === b.borderDash)
            && (a.borderDashOffset === b.borderDashOffset)
            && (a.borderJoinStyle === b.borderJoinStyle)
            && (a.pointBorderColor === b.pointBorderColor)
            && (a.pointBackgroundColor === b.pointBackgroundColor)
            && (a.pointBorderWidth === b.pointBorderWidth)
            && (a.pointRadius === b.pointRadius)
            && (a.pointHoverRadius === b.pointHoverRadius)
            && (a.pointHitRadius === b.pointHitRadius)
            && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)
            && (a.pointHoverBorderColor === b.pointHoverBorderColor)
            && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)
            && (a.pointStyle === b.pointStyle)
            && (a.hoverBackgroundColor === b.hoverBackgroundColor)
            && (a.hoverBorderColor === b.hoverBorderColor)
            && (a.hoverBorderWidth === b.hoverBorderWidth);
    };
    BaseChartDirective.prototype.updateColors = function () {
        var _this = this;
        this.datasets.forEach(function (elm, index) {
            if (_this.colors && _this.colors[index]) {
                Object.assign(elm, _this.colors[index]);
            }
            else {
                Object.assign(elm, getColors(_this.chartType, index, elm.data.length), __assign({}, elm));
            }
        });
    };
    BaseChartDirective.prototype.ngOnChanges = function (changes) {
        var updateRequired = UpdateType.Default;
        var wantUpdate = function (x) {
            updateRequired = x > updateRequired ? x : updateRequired;
        };
        // Check if the changes are in the data or datasets or labels or legend
        if (changes.hasOwnProperty('data') && changes.data.currentValue) {
            this.propagateDataToDatasets(changes.data.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {
            this.propagateDatasetsToData(changes.datasets.currentValue);
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('labels')) {
            if (this.chart) {
                this.chart.data.labels = changes.labels.currentValue;
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('legend')) {
            if (this.chart) {
                this.chart.config.options.legend.display = changes.legend.currentValue;
                this.chart.generateLegend();
            }
            wantUpdate(UpdateType.Update);
        }
        if (changes.hasOwnProperty('options')) {
            wantUpdate(UpdateType.Refresh);
        }
        switch (updateRequired) {
            case UpdateType.Update:
                this.update();
                break;
            case UpdateType.Refresh:
            case UpdateType.Default:
                this.refresh();
                break;
        }
    };
    BaseChartDirective.prototype.ngOnDestroy = function () {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.subs.forEach(function (x) { return x.unsubscribe(); });
    };
    BaseChartDirective.prototype.update = function (duration) {
        if (this.chart) {
            return this.chart.update(duration);
        }
    };
    BaseChartDirective.prototype.hideDataset = function (index, hidden) {
        this.chart.getDatasetMeta(index).hidden = hidden;
        this.chart.update();
    };
    BaseChartDirective.prototype.isDatasetHidden = function (index) {
        return this.chart.getDatasetMeta(index).hidden;
    };
    BaseChartDirective.prototype.toBase64Image = function () {
        return this.chart.toBase64Image();
    };
    BaseChartDirective.prototype.getChartConfiguration = function () {
        var _this = this;
        var datasets = this.getDatasets();
        var options = Object.assign({}, this.options);
        if (this.legend === false) {
            options.legend = { display: false };
        }
        // hook for onHover and onClick events
        options.hover = options.hover || {};
        if (!options.hover.onHover) {
            options.hover.onHover = function (event, active) {
                if (active && !active.length) {
                    return;
                }
                _this.chartHover.emit({ event: event, active: active });
            };
        }
        if (!options.onClick) {
            options.onClick = function (event, active) {
                _this.chartClick.emit({ event: event, active: active });
            };
        }
        var mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
        var chartConfig = {
            type: this.chartType,
            data: {
                labels: this.labels || [],
                datasets: datasets
            },
            plugins: this.plugins,
            options: mergedOptions,
        };
        return chartConfig;
    };
    BaseChartDirective.prototype.getChartBuilder = function (ctx /*, data:any[], options:any*/) {
        var chartConfig = this.getChartConfiguration();
        return new Chart$1(ctx, chartConfig);
    };
    BaseChartDirective.prototype.smartMerge = function (options, overrides, level) {
        var _this = this;
        if (level === void 0) { level = 0; }
        if (level === 0) {
            options = cloneDeep(options);
        }
        var keysToUpdate = Object.keys(overrides);
        keysToUpdate.forEach(function (key) {
            if (Array.isArray(overrides[key])) {
                var arrayElements = options[key];
                if (arrayElements) {
                    arrayElements.forEach(function (r) {
                        _this.smartMerge(r, overrides[key][0], level + 1);
                    });
                }
            }
            else if (typeof (overrides[key]) === 'object') {
                if (!(key in options)) {
                    options[key] = {};
                }
                _this.smartMerge(options[key], overrides[key], level + 1);
            }
            else {
                options[key] = overrides[key];
            }
        });
        if (level === 0) {
            return options;
        }
    };
    BaseChartDirective.prototype.isMultiLineLabel = function (label) {
        return Array.isArray(label);
    };
    BaseChartDirective.prototype.joinLabel = function (label) {
        if (!label) {
            return null;
        }
        if (this.isMultiLineLabel(label)) {
            return label.join(' ');
        }
        else {
            return label;
        }
    };
    BaseChartDirective.prototype.propagateDatasetsToData = function (datasets) {
        this.data = this.datasets.map(function (r) { return r.data; });
        if (this.chart) {
            this.chart.data.datasets = datasets;
        }
        this.updateColors();
    };
    BaseChartDirective.prototype.propagateDataToDatasets = function (newDataValues) {
        var _this = this;
        if (this.isMultiDataSet(newDataValues)) {
            if (this.datasets && newDataValues.length === this.datasets.length) {
                this.datasets.forEach(function (dataset, i) {
                    dataset.data = newDataValues[i];
                });
            }
            else {
                this.datasets = newDataValues.map(function (data, index) {
                    return { data: data, label: _this.joinLabel(_this.labels[index]) || "Label " + index };
                });
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
        }
        else {
            if (!this.datasets) {
                this.datasets = [{ data: newDataValues }];
                if (this.chart) {
                    this.chart.data.datasets = this.datasets;
                }
            }
            else {
                this.datasets[0].data = newDataValues;
                this.datasets.splice(1); // Remove all elements but the first
            }
        }
        this.updateColors();
    };
    BaseChartDirective.prototype.isMultiDataSet = function (data) {
        return Array.isArray(data[0]);
    };
    BaseChartDirective.prototype.getDatasets = function () {
        if (!this.datasets && !this.data) {
            throw new Error("ng-charts configuration error, data or datasets field are required to render chart " + this.chartType);
        }
        // If `datasets` is defined, use it over the `data` property.
        if (this.datasets) {
            this.propagateDatasetsToData(this.datasets);
            return this.datasets;
        }
        if (this.data) {
            this.propagateDataToDatasets(this.data);
            return this.datasets;
        }
    };
    BaseChartDirective.prototype.refresh = function () {
        // if (this.options && this.options.responsive) {
        //   setTimeout(() => this.refresh(), 50);
        // }
        // todo: remove this line, it is producing flickering
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        if (this.ctx) {
            this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
        }
    };
    BaseChartDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ThemeService }
    ]; };
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "data", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "datasets", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "labels", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "options", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "chartType", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "colors", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "legend", void 0);
    __decorate([
        Input()
    ], BaseChartDirective.prototype, "plugins", void 0);
    __decorate([
        Output()
    ], BaseChartDirective.prototype, "chartClick", void 0);
    __decorate([
        Output()
    ], BaseChartDirective.prototype, "chartHover", void 0);
    BaseChartDirective = __decorate([
        Directive({
            // tslint:disable-next-line:directive-selector
            selector: 'canvas[baseChart]',
            exportAs: 'base-chart'
        })
    ], BaseChartDirective);
    return BaseChartDirective;
}());

var ChartsModule = /** @class */ (function () {
    function ChartsModule() {
    }
    ChartsModule = __decorate([
        NgModule({
            declarations: [
                BaseChartDirective
            ],
            imports: [],
            exports: [
                BaseChartDirective
            ]
        })
    ], ChartsModule);
    return ChartsModule;
}());

function monkeyPatchChartJsLegend() {
    if (typeof Chart === 'undefined') {
        console.log('Chart not defined (guessing this is a universal build, and I don\'t know why this happens -- Aviad)');
        return;
    }
    var plugins = Chart.plugins.getAll();
    var legend = plugins.filter(function (p) { return p.id === 'legend'; })[0];
    legend._element.prototype.fit = fit;
    legend._element.prototype.draw = draw;
    var helpers = Chart.helpers;
    var defaults = Chart.defaults;
    var valueOrDefault = helpers.valueOrDefault;
    function getBoxWidth(labelOpts, fontSize) {
        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?
            fontSize :
            labelOpts.boxWidth;
    }
    function fit() {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;
        var labelFont = helpers.options._parseFont(labelOpts);
        var fontSize = labelFont.size;
        // Reset hit boxes
        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();
        if (isHorizontal) {
            minSize.width = me.maxWidth; // fill all the width
            minSize.height = display ? 10 : 0;
        }
        else {
            minSize.width = display ? 10 : 0;
            minSize.height = me.maxHeight; // fill all the height
        }
        var getMaxLineWidth = function (textLines) {
            return textLines.map(function (textLine) {
                return ctx.measureText(textLine).width;
            }).reduce(function (acc, v) {
                return v > acc ? v : acc;
            }, 0);
        };
        // Increase sizes here
        if (display) {
            ctx.font = labelFont.string;
            if (isHorizontal) {
                // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
                var lineWidths = me.lineWidths = [0];
                var lineHeights = me.lineHeights = [];
                var currentLineHeight = 0;
                var lineIndex = 0;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                helpers.each(me.legendItems, function (legendItem, i) {
                    var width, height;
                    if (helpers.isArray(legendItem.text)) {
                        width = getMaxLineWidth(legendItem.text);
                        height = fontSize * legendItem.text.length + labelOpts.padding;
                    }
                    else {
                        width = ctx.measureText(legendItem.text).width;
                        height = fontSize + labelOpts.padding;
                    }
                    width += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);
                    if (lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                        lineHeights.push(currentLineHeight);
                        currentLineHeight = 0;
                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                        lineIndex++;
                    }
                    legendItem.lineOrColumnIndex = lineIndex;
                    if (height > currentLineHeight) {
                        currentLineHeight = height;
                    }
                    // Store the hitbox width and height here. Final position will be updated in `draw`
                    hitboxes[i] = {
                        left: 0,
                        top: 0,
                        width: width,
                        height: height,
                    };
                    lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                });
                lineHeights.push(currentLineHeight);
                minSize.height += lineHeights.reduce(function (acc, v) {
                    return acc + v;
                }, 0);
            }
            else {
                var vPadding = labelOpts.padding;
                var columnWidths = me.columnWidths = [];
                var columnHeights = me.columnHeights = [];
                var totalWidth = labelOpts.padding;
                var currentColWidth = 0;
                var currentColHeight = 0;
                var columnIndex = 0;
                helpers.each(me.legendItems, function (legendItem, i) {
                    var itemWidth;
                    var height;
                    if (helpers.isArray(legendItem.text)) {
                        itemWidth = getMaxLineWidth(legendItem.text);
                        height = fontSize * legendItem.text.length;
                    }
                    else {
                        itemWidth = ctx.measureText(legendItem.text).width;
                        height = fontSize;
                    }
                    itemWidth += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);
                    // If too tall, go to new column
                    if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                        totalWidth += currentColWidth + labelOpts.padding;
                        columnWidths.push(currentColWidth); // previous column width
                        columnHeights.push(currentColHeight);
                        currentColWidth = 0;
                        currentColHeight = 0;
                        columnIndex++;
                    }
                    legendItem.lineOrColumnIndex = columnIndex;
                    // Get max width
                    currentColWidth = Math.max(currentColWidth, itemWidth);
                    currentColHeight += height + vPadding;
                    // Store the hitbox width and height here. Final position will be updated in `draw`
                    hitboxes[i] = {
                        left: 0,
                        top: 0,
                        width: itemWidth,
                        height: height
                    };
                });
                totalWidth += currentColWidth;
                columnWidths.push(currentColWidth);
                columnHeights.push(currentColHeight);
                minSize.width += totalWidth;
            }
        }
        me.width = minSize.width;
        me.height = minSize.height;
    }
    function draw() {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendHeight = me.height;
        var columnHeights = me.columnHeights;
        var columnWidths = me.columnWidths;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;
        var lineHeights = me.lineHeights;
        if (opts.display) {
            var ctx = me.ctx;
            var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            // Canvas setup
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor; // for strikethrough effect
            ctx.fillStyle = fontColor; // render in correct colour
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes;
            // current position
            var drawLegendBox = function (x, y, legendItem) {
                if (isNaN(boxWidth) || boxWidth <= 0) {
                    return;
                }
                // Set the ctx for the box
                ctx.save();
                var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
                ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
                ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
                ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
                if (ctx.setLineDash) {
                    // IE 9 and 10 do not support line dash
                    ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
                }
                if (opts.labels && opts.labels.usePointStyle) {
                    // Recalculate x and y for drawPoint() because its expecting
                    // x and y to be center of figure (instead of top left)
                    var radius = boxWidth * Math.SQRT2 / 2;
                    var centerX = x + boxWidth / 2;
                    var centerY = y + fontSize / 2;
                    // Draw pointStyle as legend symbol
                    helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
                }
                else {
                    // Draw box as legend symbol
                    if (lineWidth !== 0) {
                        ctx.strokeRect(x, y, boxWidth, fontSize);
                    }
                    ctx.fillRect(x, y, boxWidth, fontSize);
                }
                ctx.restore();
            };
            var drawStrikeThrough = function (x, y, w) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                ctx.stroke();
            };
            var drawCrossOver = function (x, y, w, h) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y + h);
                ctx.moveTo(x, y + h);
                ctx.lineTo(x + w, y);
                ctx.stroke();
            };
            var fillText = function (x, y, legendItem, textWidth) {
                var halfFontSize = fontSize / 2;
                var xLeft = boxWidth + halfFontSize + x;
                var yMiddle = y + halfFontSize;
                if (helpers.isArray(legendItem.text)) {
                    helpers.each(legendItem.text, function (textLine, index) {
                        var lineOffset = index * fontSize;
                        ctx.fillText(textLine, xLeft, yMiddle + lineOffset);
                    });
                }
                else {
                    ctx.fillText(legendItem.text, xLeft, yMiddle);
                }
                if (legendItem.hidden) {
                    if (helpers.isArray(legendItem.text)) {
                        drawCrossOver(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize - 1));
                    }
                    else {
                        drawStrikeThrough(xLeft, yMiddle, textWidth);
                    }
                }
            };
            var alignmentOffset = function (dimension, blockSize) {
                switch (opts.align) {
                    case 'start':
                        return labelOpts.padding;
                    case 'end':
                        return dimension - blockSize;
                    default: // center
                        return (dimension - blockSize + labelOpts.padding) / 2;
                }
            };
            // Horizontal
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
                cursor = {
                    x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                    y: me.top + labelOpts.padding,
                    line: 0
                };
            }
            else {
                cursor = {
                    x: me.left + labelOpts.padding,
                    y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                    line: 0
                };
            }
            helpers.each(me.legendItems, function (legendItem, i) {
                var textWidth, height, boxTopOffset;
                if (legendItem.lineOrColumnIndex > cursor.line) {
                    if (isHorizontal) {
                        cursor.y += lineHeights[cursor.line];
                        cursor.line = legendItem.lineOrColumnIndex;
                        cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                    }
                    else {
                        cursor.x += columnWidths[cursor.line] + labelOpts.padding;
                        cursor.line = legendItem.lineOrColumnIndex;
                        cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
                    }
                }
                if (helpers.isArray(legendItem.text)) {
                    textWidth = legendItem.text.map(function (textLine) {
                        return ctx.measureText(textLine).width;
                    }).reduce(function (acc, v) {
                        return v > acc ? v : acc;
                    }, 0);
                    boxTopOffset = fontSize / 2 * (legendItem.text.length - 1);
                    height = fontSize * legendItem.text.length;
                }
                else {
                    textWidth = ctx.measureText(legendItem.text).width;
                    boxTopOffset = 0;
                    height = fontSize;
                }
                var width = boxWidth + (fontSize / 2) + textWidth;
                var x = cursor.x;
                var y = cursor.y;
                var topOffset = isHorizontal ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2) : 0;
                drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);
                hitboxes[i].left = x;
                hitboxes[i].top = y;
                // Fill the actual label
                fillText(x, y + topOffset, legendItem, textWidth);
                if (isHorizontal) {
                    cursor.x += width + labelOpts.padding;
                }
                else {
                    cursor.y += height + labelOpts.padding;
                }
            });
        }
    }
}

function monkeyPatchChartJsTooltip() {
    if (typeof Chart === 'undefined') {
        console.log('Chart not defined (guessing this is a universal build, and I don\'t know why this happens -- Aviad)');
        return;
    }
    Chart.Tooltip.prototype.drawBody = drawBody;
    var helpers = Chart.helpers;
    function getAlignedX(vm, align) {
        return align === 'center'
            ? vm.x + vm.width / 2
            : align === 'right'
                ? vm.x + vm.width - vm.xPadding
                : vm.x + vm.xPadding;
    }
    function drawBody(pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign);
        // Before Body
        var fillLineOfText = function (line) {
            ctx.fillText(line, pt.x + xLinePadding, pt.y);
            pt.y += bodyFontSize + bodySpacing;
        };
        // Before body lines
        ctx.fillStyle = vm.bodyFontColor;
        helpers.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right'
            ? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)
            : 0;
        // Draw body lines now
        helpers.each(body, function (bodyItem, i) {
            textColor = vm.labelTextColors[i];
            ctx.fillStyle = textColor;
            helpers.each(bodyItem.before, fillLineOfText);
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
                // Fill a white rect so that colours merge nicely if the opacity is < 1
                ctx.fillStyle = vm.legendColorBackground;
                ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);
                // Border
                ctx.lineWidth = 1;
                ctx.strokeStyle = labelColors[i].borderColor;
                ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);
                // Inner square
                ctx.fillStyle = labelColors[i].backgroundColor;
                ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                ctx.fillStyle = textColor;
            }
            helpers.each(bodyItem.lines, fillLineOfText);
            helpers.each(bodyItem.after, fillLineOfText);
        });
        // Reset back to 0 for after body
        xLinePadding = 0;
        // After body lines
        helpers.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { BaseChartDirective, ChartsModule, ThemeService, defaultColors, monkeyPatchChartJsLegend, monkeyPatchChartJsTooltip };
//# sourceMappingURL=rinminase-ng-charts.js.map
